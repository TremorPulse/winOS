#include <kernel/exceptions.h>
#include <kernel/panic.h>
#include <kernel/printk.h>
#include <kernel/kernel_levels.h>

/* Exceptions are interrupts generated by the CPU when errors occur.
 * These are classified into three types:
 * - Faults: can be corrected and continue program execution
 * - Traps: reported immediately after the interrupt instruction
 * - Aborts: a severe, unrecoverable error
 * Some exceptions push a 32-bit error code and number on to the top of the stack 
 * for additional information about the error. 
 */

/* We don't expect many exceptions this early on into development. */
void exception_handler(uint32_t *stack_ptr) {
    // Fixed stack layout - your original had wrong field sizes
    uint32_t edi = stack_ptr[0];   // From pusha
    uint32_t esi = stack_ptr[1];   // From pusha  
    uint32_t ebp = stack_ptr[2];   // From pusha
    // skip esp at stack_ptr[3]     // From pusha (ignored)
    uint32_t ebx = stack_ptr[4];   // From pusha
    uint32_t edx = stack_ptr[5];   // From pusha
    uint32_t ecx = stack_ptr[6];   // From pusha
    uint32_t eax = stack_ptr[7];   // From pusha
    uint32_t ds = stack_ptr[8];    // Data segment you pushed
    uint32_t exception_num = stack_ptr[9];  // Exception number
    uint32_t error_code = stack_ptr[10];    // Error code
    uint32_t eip = stack_ptr[11];  // From CPU interrupt
    uint32_t cs = stack_ptr[12];   // From CPU interrupt
    uint32_t eflags = stack_ptr[13]; // From CPU interrupt
    
    switch(exception_num) {
        case 0: // Division by zero
            printk(KERN_CRIT, "Division by zero at EIP: 0x%x\n", eip);
            printk(KERN_CRIT, "EAX: 0x%x, EBX: 0x%x, ECX: 0x%x, EDX: 0x%x\n",
                   eax, ebx, ecx, edx);
            panic("Division by zero");
            break;
        case 13: // General Protection Fault
            printk(KERN_CRIT, "General Protection Fault at EIP: 0x%x\n", eip);
            printk(KERN_CRIT, "Error code: 0x%x\n", error_code);
            panic("General protection fault");
            break;
        case 14: // Page Fault
        {
            uint32_t faulting_address;
            asm volatile("mov %%cr2, %0" : "=r" (faulting_address));
            printk(KERN_CRIT, "Page Fault at EIP: 0x%x\n", eip);
            printk(KERN_CRIT, "Faulting address: 0x%x\n", faulting_address);
            printk(KERN_CRIT, "Error code: 0x%x\n", error_code);
            panic("Page fault");
        }
        break;
        default:
            printk(KERN_CRIT, "Unknown exception %d at EIP: 0x%x\n", exception_num, eip);
            panic("Unknown exception");
    }
}


void __attribute__((weak)) divide_error_handler(struct exception_frame *frame) {
    printk(KERN_CRIT, "Division by zero at EIP: 0x%x\n", frame->eip);
    printk(KERN_CRIT, "EAX: 0x%x, EBX: 0x%x, ECX: 0x%x, EDX: 0x%x\n", 
           frame->eax, frame->ebx, frame->ecx, frame->edx);
    panic("Division by zero");
}

void __attribute__((weak)) general_protection_handler(struct exception_frame *frame) {
    printk(KERN_CRIT, "General Protection Fault at EIP: 0x%x\n", frame->eip);
    printk(KERN_CRIT, "Error code: 0x%x\n", frame->error_code);
    panic("General protection fault");
}

void __attribute__((weak)) page_fault_handler(struct exception_frame *frame) {
    uint32_t faulting_address;
    asm volatile("mov %%cr2, %0" : "=r" (faulting_address));
    
    printk(KERN_CRIT, "Page Fault at EIP: 0x%x\n", frame->eip);
    printk(KERN_CRIT, "Faulting address: 0x%x\n", faulting_address);
    printk(KERN_CRIT, "Error code: 0x%x\n", frame->error_code);
    panic("Page fault");
}

void exceptions_init(void) {
    printk(KERN_INFO, "\nExceptions OK.\n");
}